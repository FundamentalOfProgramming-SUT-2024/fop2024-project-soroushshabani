#include <ncurses.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>

// ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
#define MAX_ROOMS 6
#define MIN_ROOM_WIDTH 6
#define MAX_ROOM_WIDTH 15
#define MIN_ROOM_HEIGHT 6
#define MAX_ROOM_HEIGHT 8
#define ROOM_PADDING 2
#define MAX_PILLARS 3
#define MAX_ROWS 100
#define MAX_COLS 100
#define MAX_INVENTORY_ITEMS 100
#define ITEM_NAME_LENGTH 50
#define MACE_ICON "ğŸª¢"
#define DAGGER_ICON "ğŸ“Œ"
#define WAND_ICON "ğŸª„"
#define ARROW_ICON "ğŸ¹"
#define SWORD_ICON "ğŸ—¡"
#define speed_ICON "ğŸƒâ€â™‚ï¸"
#define health_ICON "â¤ï¸"
#define damage_ICON "ğŸ”¥"
#define TOTAL_DEMONS 10
#define TOTAL_FIRE 7
#define TOTAL_SNAKES 5
#define TOTAL_GIANTS 4
#define TOTAL_UNDEAD 2


typedef struct {
    int x, y;
    int width, height;
    int door_x, door_y; // Door position
    int has_demon;
    int has_firemonster;
    int has_snake;
    int has_giant;
    int has_undead;
} Room;
typedef struct {
    char name[20];
    int duration;
    int active;
} Spell;
typedef struct {
    char name[ITEM_NAME_LENGTH];
    char type[ITEM_NAME_LENGTH];
    int damage;
} Item;
typedef struct {
    int player_x, player_y; // Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒÚ©Ù†
    int player_hp;
    int hunger;
    int speed_move_counter;  // Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ú¯Ø±Ø³Ù†Ú¯ÛŒ Ù‡Ù†Ú¯Ø§Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø·Ù„Ø³Ù… Speed
    int food_count;
    int gold_count;
    Item inventory[MAX_INVENTORY_ITEMS]; // Ø¢ÛŒØªÙ…â€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
    int inventory_count;
    Room rooms[MAX_ROOMS];  // Ø°Ø®ÛŒØ±Ù‡â€ŒÛŒ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
    char map[MAX_ROWS][MAX_COLS]; // Ø°Ø®ÛŒØ±Ù‡â€ŒÛŒ Ù†Ù‚Ø´Ù‡
} GameState;
typedef struct {
    int x, y;        // Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‡ÛŒÙˆÙ„Ø§
    int hp;          // Ø³Ù„Ø§Ù…ØªÛŒ Ù‡ÛŒÙˆÙ„Ø§
    int active;      // Ø¢ÛŒØ§ Ù‡ÛŒÙˆÙ„Ø§ ÙØ¹Ø§Ù„ Ø§Ø³Øª ÛŒØ§ Ø®ÛŒØ±
    int room_index;  // Ø´Ø§Ø®Øµ Ø§ØªØ§Ù‚ Ú©Ù‡ Ù‡ÛŒÙˆÙ„Ø§ Ø¯Ø± Ø¢Ù† Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯
    int move_count;
} Monster;
Monster demons[TOTAL_DEMONS];
int demon_count = 0;
Monster undeads[TOTAL_UNDEAD];
int undead_count = 0;
Monster giants[TOTAL_GIANTS];
int giant_count = 0;
Monster snakes[TOTAL_SNAKES];
int snake_count = 0;
Monster firemonsters[TOTAL_FIRE];
int fire_count = 0;
Item inventory[MAX_INVENTORY_ITEMS];
int inventory_count = 0;
char current_message[100] = ""; // Ù…ØªØºÛŒØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ§Ù… ÙØ¹Ù„ÛŒ
char map[MAX_ROWS][MAX_COLS];
char trap_map[MAX_ROWS][MAX_COLS]; // Ù†Ù‚Ø´Ù‡ ØªÙ„Ù‡â€ŒÙ‡Ø§
char gold_message[50] = "";
int gold_count = 0;
int player_hp = 40;
int placed_food = 0; // Ø´Ù…Ø§Ø±Ø´ ØºØ°Ø§ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡
int hunger = 60;
Spell active_spells[3];  // Ø³Ù‡ Ø·Ù„Ø³Ù… Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù†Ø¯ Ù‡Ù…Ø²Ù…Ø§Ù† ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ù†Ø¯
int food_count = 0;   // ØªØ¹Ø¯Ø§Ø¯ ØºØ°Ø§Ù‡Ø§ÛŒ Ù‡Ù…Ø±Ø§Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù†
char *background_music = "/Users/soroushshabani/Downloads/Hans Zimmer - cornfield chase (320).mp3";// Ø¨Ø±Ø±Ø³ÛŒ ØªØ¯Ø§Ø®Ù„ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
char current_username[100] = "Guest";  // Ù…Ù‚Ø¯Ø§Ø± Ù¾ÛŒØ´â€ŒÙØ±Ø¶
// ===================== ğŸ”¥ FUNCTION LIST ğŸ”¥ ===================== //
// â¤ Utility Functions
void initialize_trap_map();          // ğŸ¯ Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ù†Ù‚Ø´Ù‡ ØªÙ„Ù‡â€ŒÙ‡Ø§
void play_background_music(const char* music); // ğŸµ Ù¾Ø®Ø´ Ù…ÙˆØ³ÛŒÙ‚ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
void type_text(const char* text, int row, int col); // âœï¸ ØªØ§ÛŒÙ¾ Ù…ØªÙ†

// â¤ Game Functions
void start_game();                   // ğŸ® Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ
void show_pre_game_menu();            // ğŸ“œ Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ù¾ÛŒØ´ Ø§Ø² Ø¨Ø§Ø²ÛŒ
void game_over_screen();              // ğŸ’€ ØµÙØ­Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø¨Ø§Ø²ÛŒ

// â¤ Room Functions
void create_rooms(Room rooms[], int count); // ğŸ  Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
void draw_room(Room room, Room rooms[], int count); // ğŸ  Ø±Ø³Ù… Ø§ØªØ§Ù‚
void place_window_in_room(Room* room, Room rooms[], int count); // ğŸªŸ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ø§ØªØ§Ù‚
void draw_door(int door_x, int door_y); // ğŸšª Ø±Ø³Ù… Ø¯Ø± Ø§ØªØ§Ù‚
void add_pillars(Room room); // ğŸ› Ø§ÙØ²ÙˆØ¯Ù† Ø³ØªÙˆÙ†â€ŒÙ‡Ø§
void add_traps_to_room(Room* room); // â˜ ï¸ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ØªÙ„Ù‡â€ŒÙ‡Ø§ Ø¨Ù‡ Ø§ØªØ§Ù‚

// â¤ Character Functions
void move_character(int* x, int* y, char* prev_cell, GameState* game_state); // ğŸƒ Ø­Ø±Ú©Øª Ú©Ø§Ø±Ø§Ú©ØªØ±
void start_continuous_move(int x_dir, int y_dir); // ğŸƒâ€â™‚ï¸ Ø­Ø±Ú©Øª Ù…Ø¯Ø§ÙˆÙ… Ú©Ø§Ø±Ø§Ú©ØªØ±

// â¤ Monster Functions
void move_demon(Monster* demon); // ğŸ‘¿ Ø­Ø±Ú©Øª Ø¯ÛŒÙˆ
void move_undead(Monster* undead); // ğŸ’€ Ø­Ø±Ú©Øª Ù…Ø±Ø¯Ù‡ Ù…ØªØ­Ø±Ú©
void move_giant(Monster* giant); // ğŸ¦ Ø­Ø±Ú©Øª ØºÙˆÙ„

// â¤ Item Functions
void add_food_to_room(Room* room); // ğŸ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ØºØ°Ø§ Ø¨Ù‡ Ø§ØªØ§Ù‚
void add_mace_to_room(Room* room); // ğŸª¢ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø´Ù„Ø§Ù‚ Ø¨Ù‡ Ø§ØªØ§Ù‚
void add_wand_to_room(Room* room); // ğŸª„ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú†ÙˆØ¨ Ø¬Ø§Ø¯Ùˆ Ø¨Ù‡ Ø§ØªØ§Ù‚
void add_gold_bag_to_room(Room* room); // ğŸ’° Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú©ÛŒØ³Ù‡ Ø·Ù„Ø§

// â¤ UI & Menu Functions
void show_inventory(); // ğŸ’ Ù†Ù…Ø§ÛŒØ´ Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
void show_profile(); // ğŸ‘¤ Ù†Ù…Ø§ÛŒØ´ Ù¾Ø±ÙˆÙØ§ÛŒÙ„
void show_settings(); // âš™ï¸ Ù†Ù…Ø§ÛŒØ´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
void show_leaderboard(); // ğŸ† Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯
void show_saved_games(); // ğŸ’¾ Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ´Ø¯Ù‡

// â¤ Authentication & User Management
void signin(FILE* file); // ğŸ” Ø«Ø¨Øª Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±
void login(FILE* file); // ğŸ”‘ ÙˆØ±ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø±
void forgot_password(FILE* file); // ğŸ”“ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
void login_guest(); // ğŸ‘¤ ÙˆØ±ÙˆØ¯ Ù…Ù‡Ù…Ø§Ù†

// â¤ Save & Load Functions
void save_game(const char* filename, GameState* game_state); // ğŸ’¾ Ø°Ø®ÛŒØ±Ù‡ Ø¨Ø§Ø²ÛŒ
int load_game(const char* filename, GameState* game_state); // ğŸ“‚ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨Ø§Ø²ÛŒ
void add_save_file_to_list(const char* filename); // ğŸ“‹ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„ Ø°Ø®ÛŒØ±Ù‡â€ŒØ´Ø¯Ù‡ Ø¨Ù‡ Ù„ÛŒØ³Øª
void load_save_list(); // ğŸ“œ Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ´Ø¯Ù‡

// â¤ Main Menu Functions
void show_menu(const char* choices[], int n_choices, FILE* file); // ğŸ“œ Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ
void show_ascii_art(); // ğŸ¨ Ù†Ù…Ø§ÛŒØ´ ASCII Art
void show_loading_animation(); // â³ Ù†Ù…Ø§ÛŒØ´ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ù„ÙˆØ¯ÛŒÙ†Ú¯
int check_overlap(Room new_room, Room rooms[], int count) {
    for (int i = 0; i < count; i++) {
        if (new_room.x < rooms[i].x + rooms[i].width + ROOM_PADDING &&
            new_room.x + new_room.width > rooms[i].x - ROOM_PADDING &&
            new_room.y < rooms[i].y + rooms[i].height + ROOM_PADDING &&
            new_room.y + new_room.height > rooms[i].y - ROOM_PADDING) {
            return 1;
        }
    }
    return 0;
}

// ØªÙˆÙ„ÛŒØ¯ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
void create_rooms(Room rooms[], int count) {
    for (int i = 0; i < count; i++) {
        Room new_room;
        new_room.width = rand() % (MAX_ROOM_WIDTH - MIN_ROOM_WIDTH + 1) + MIN_ROOM_WIDTH;
        new_room.height = rand() % (MAX_ROOM_HEIGHT - MIN_ROOM_HEIGHT + 1) + MIN_ROOM_HEIGHT;
        do {
            new_room.x = rand() % (COLS - new_room.width - 3);
            new_room.y = rand() % (LINES - new_room.height - 3);
        } while (check_overlap(new_room, rooms, i));
        rooms[i] = new_room;
    }
}

// Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø§ØªØ§Ù‚ Ø¯Ø± Ø³Ù…Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø±
int room_in_direction(Room room, Room rooms[], int count, char direction) {
    for (int i = 0; i < count; i++) {
        switch (direction) {
            case 'U': // Ø¨Ø§Ù„Ø§
                if (room.x < rooms[i].x + rooms[i].width &&
                    room.x + room.width > rooms[i].x &&
                    room.y > rooms[i].y + rooms[i].height) {
                    return 1;
                }
                break;
            case 'D': // Ù¾Ø§ÛŒÛŒÙ†
                if (room.x < rooms[i].x + rooms[i].width &&
                    room.x + room.width > rooms[i].x &&
                    room.y + room.height < rooms[i].y) {
                    return 1;
                }
                break;
            case 'L': // Ú†Ù¾
                if (room.y < rooms[i].y + rooms[i].height &&
                    room.y + room.height > rooms[i].y &&
                    room.x > rooms[i].x + rooms[i].width) {
                    return 1;
                }
                break;
            case 'R': // Ø±Ø§Ø³Øª
                if (room.y < rooms[i].y + rooms[i].height &&
                    room.y + room.height > rooms[i].y &&
                    room.x + room.width < rooms[i].x) {
                    return 1;
                }
                break;
        }
    }
    return 0;
}

// ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ø¯ÛŒÙˆØ§Ø± Ø§ØªØ§Ù‚
void place_window_in_room(Room *room, Room rooms[], int count) {
    int window_x = 0, window_y = 0;
    int side = rand() % 4; // Ø§Ù†ØªØ®Ø§Ø¨ ÛŒÚ© Ø·Ø±Ù (Ø¨Ø§Ù„Ø§ØŒ Ù¾Ø§ÛŒÛŒÙ†ØŒ Ú†Ù¾ ÛŒØ§ Ø±Ø§Ø³Øª)

    // Ø§Ù†ØªØ®Ø§Ø¨ Ø¯ÛŒÙˆØ§Ø± Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† Ù¾Ù†Ø¬Ø±Ù‡
    if (side == 0) { // Ø¯ÛŒÙˆØ§Ø± Ø¨Ø§Ù„Ø§ÛŒÛŒ
        window_x = room->x + 1 + rand() % (room->width - 2);
        window_y = room->y;
    } else if (side == 1) { // Ø¯ÛŒÙˆØ§Ø± Ù¾Ø§ÛŒÛŒÙ†ÛŒ
        window_x = room->x + 1 + rand() % (room->width - 2);
        window_y = room->y + room->height - 1;
    } else if (side == 2) { // Ø¯ÛŒÙˆØ§Ø± Ú†Ù¾
        window_x = room->x;
        window_y = room->y + 1 + rand() % (room->height - 2);
    } else { // Ø¯ÛŒÙˆØ§Ø± Ø±Ø§Ø³Øª
        window_x = room->x + room->width - 1;
        window_y = room->y + 1 + rand() % (room->height - 2);
    }

    // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± ÛŒÚ© Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…Ø¹ØªØ¨Ø± Ù‚Ø±Ø§Ø± Ú¯ÛŒØ±Ø¯
    if (map[window_y][window_x] == '+' || map[window_y][window_x] == '=') {
        return; // Ø§Ú¯Ø± Ø¬Ø§ÛŒ Ù¾Ù†Ø¬Ø±Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø´ØºØ§Ù„ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ Ø§Ø² Ø¢Ù† ØµØ±Ù Ù†Ø¸Ø± Ú©Ù†
    }

    // Ø§Ú¯Ø± Ø§ØªØ§Ù‚ Ø¯Ø± Ø¬Ù‡Øª Ù¾Ù†Ø¬Ø±Ù‡ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ Ø¢Ù† Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
    if (room_in_direction(*room, rooms, count, side)) {
        map[window_y][window_x] = '='; // Ù†Ù…Ø§ÛŒ Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ù†Ù‚Ø´Ù‡
    }
}

// Ø±Ø³Ù… Ø§ØªØ§Ù‚
void draw_room(Room room, Room rooms[], int count) {
    for (int i = 0; i < room.height; i++) {
        for (int j = 0; j < room.width; j++) {
            int cur_x = room.x + j;
            int cur_y = room.y + i;
            if (i == 0 || i == room.height - 1 || j == 0 || j == room.width - 1) {
                // Ø§Ú¯Ø± Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯ÛŒÙˆØ§Ø± Ø¨Ø§Ù„Ø§ÛŒÛŒØŒ Ù¾Ø§ÛŒÛŒÙ†ÛŒØŒ Ú†Ù¾ ÛŒØ§ Ø±Ø§Ø³Øª Ø¨Ø§Ø´ÛŒÙ…
                if (j == room.width / 2 && i == 0 && room_in_direction(room, rooms, count, 'U')) {
                    mvaddch(cur_y, cur_x, '='); // Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ø¨Ø§Ù„Ø§ÛŒ Ø§ØªØ§Ù‚
                } else if (j == room.width / 2 && i == room.height - 1 && room_in_direction(room, rooms, count, 'D')) {
                    mvaddch(cur_y, cur_x, '='); // Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ù¾Ø§ÛŒÛŒÙ† Ø§ØªØ§Ù‚
                } else if (i == room.height / 2 && j == 0 && room_in_direction(room, rooms, count, 'L')) {
                    mvaddch(cur_y, cur_x, '='); // Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ø³Ù…Øª Ú†Ù¾ Ø§ØªØ§Ù‚
                } else if (i == room.height / 2 && j == room.width - 1 && room_in_direction(room, rooms, count, 'R')) {
                    mvaddch(cur_y, cur_x, '='); // Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø± Ø³Ù…Øª Ø±Ø§Ø³Øª Ø§ØªØ§Ù‚
                } else {
                    mvaddch(cur_y, cur_x, (i == 0 || i == room.height - 1) ? '-' : '|');
                }
            } else {
                mvaddch(cur_y, cur_x, '.');
            }
        }
    }
}

// **Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ ØªØµØ§Ø¯ÙÛŒ Ø¯Ø§Ø®Ù„ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§**
void add_pillars(Room room) {
    int num_pillars = rand() % (MAX_PILLARS + 1); // Û° ØªØ§ Û³ Ø³ØªÙˆÙ† Ø¯Ø± Ù‡Ø± Ø§ØªØ§Ù‚
    for (int i = 0; i < num_pillars; i++) {
        int pillar_x, pillar_y;
        do {
            pillar_x = room.x + 1 + rand() % (room.width - 2);
            pillar_y = room.y + 1 + rand() % (room.height - 2);
        } while (mvinch(pillar_y, pillar_x) != '.'); // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø±ÙˆÛŒ Ø¯ÛŒÙˆØ§Ø±
        attron(COLOR_PAIR(3)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

        mvaddch(pillar_y, pillar_x, 'O'); // Ù†Ù…Ø§ÛŒØ´ Ø³ØªÙˆÙ†
        attroff(COLOR_PAIR(3)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

    }
}

// Ø±Ø³Ù… Ø¯Ø±
void draw_door(int door_x, int door_y) {
    mvaddch(door_y, door_x, '+');
}

// Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ ÛŒÚ© Ù†Ù‚Ø·Ù‡ Ø¯Ø§Ø®Ù„ Ø§ØªØ§Ù‚ Ø§Ø³Øª
int is_point_inside_room(int x, int y, Room room) {
    return (x >= room.x && x < room.x + room.width &&
            y >= room.y && y < room.y + room.height);
}

// Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø³ÛŒØ± Ø±Ø§Ù‡Ø±Ùˆ
int corridor_clear(int sx, int sy, int ex, int ey, int cy, Room rooms[], int count) {
    int step;
    for (int i = 0; i < count; i++) {
        if (is_point_inside_room(sx, cy, rooms[i]) || is_point_inside_room(ex, cy, rooms[i]))
            return 0;
    }
    step = (sy < cy) ? 1 : -1;
    for (int y = sy; y != cy; y += step)
        for (int i = 0; i < count; i++)
            if (is_point_inside_room(sx, y, rooms[i]))
                return 0;

    step = (sx < ex) ? 1 : -1;
    for (int x = sx; x != ex; x += step)
        for (int i = 0; i < count; i++)
            if (is_point_inside_room(x, cy, rooms[i]))
                return 0;

    step = (cy < ey) ? 1 : -1;
    for (int y = cy; y != ey; y += step)
        for (int i = 0; i < count; i++)
            if (is_point_inside_room(ex, y, rooms[i]))
                return 0;

    return 1;
}
void add_traps_to_room(Room *room) {
    for (int i = 0; i < 3; i++) {
        int trap_x, trap_y;
        do {
            trap_x = room->x + 1 + rand() % (room->width - 2);
            trap_y = room->y + 1 + rand() % (room->height - 2);
        } while (trap_map[trap_y][trap_x] == 'T'); // Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ ØªÙ„Ù‡ Ø±ÙˆÛŒ ØªÙ„Ù‡ Ø¯ÛŒÚ¯Ø±ÛŒ Ù‚Ø±Ø§Ø± Ù†Ú¯ÛŒØ±Ø¯

        map[trap_y][trap_x] = 'T'; // Mark position of gold bag in map
        attron(COLOR_PAIR(1)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
        mvaddch(trap_y, trap_x, 'T'); // Display gold bag on screen
        attroff(COLOR_PAIR(1)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

    }
}

// Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ Ø¨Ù‡ Ù†Ù‚Ø´Ù‡ ØªÙ„Ù‡â€ŒÙ‡Ø§
void initialize_trap_map() {
    for (int i = 0; i < MAX_ROWS; i++) {
        for (int j = 0; j < MAX_COLS; j++) {
            trap_map[i][j] = ' '; // Ù‡ÛŒÚ† ØªÙ„Ù‡â€ŒØ§ÛŒ Ø¯Ø± Ø§Ø¨ØªØ¯Ø§ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯
        }
    }
}
void game_over_screen() {

    clear();
    attron(A_BOLD | COLOR_PAIR(1));
    mvprintw(LINES / 2 - 1, (COLS - 10) / 2, "ğŸ’€ GAME OVER ğŸ’€");
    mvprintw(LINES / 2 + 1, (COLS - 30) / 2, "Press ENTER to return to menu...");
    attroff(A_BOLD | COLOR_PAIR(1));
    refresh();
    while (getch() != '\n'); // ØµØ¨Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ ØªØ§ Ú©Ø§Ø±Ø¨Ø± Enter Ø¨Ø²Ù†Ø¯
    clear();
}
// Ø±Ø³Ù… Ø±Ø§Ù‡Ø±Ùˆ
void draw_corridor(int sx, int sy, int ex, int ey, int cy) {
    int step;
    step = (sy < cy) ? 1 : -1;
    for (int y = sy; y != cy; y += step)
        mvaddch(y, sx, '#');
    mvaddch(cy, sx, '#');

    step = (sx < ex) ? 1 : -1;
    for (int x = sx; x != ex; x += step)
        mvaddch(cy, x, '#');
    mvaddch(cy, ex, '#');

    step = (cy < ey) ? 1 : -1;
    for (int y = cy; y != ey; y += step)
        mvaddch(y, ex, '#');
    mvaddch(ey, ex, '#');
}

// Ø§ØªØµØ§Ù„ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
int connect_rooms(Room roomA, Room roomB, Room rooms[], int total_rooms) {
    int doorA_x = roomA.x + roomA.width - 1;
    int doorA_y = roomA.y + roomA.height / 2;
    int doorB_x = roomB.x;
    int doorB_y = roomB.y + roomB.height / 2;

    int corridor_start_x = doorA_x + 1;
    int corridor_start_y = doorA_y;
    int corridor_end_x = doorB_x - 1;
    int corridor_end_y = doorB_y;

    int cy = (corridor_start_y + corridor_end_y) / 2;

    if (corridor_clear(corridor_start_x, corridor_start_y, corridor_end_x, corridor_end_y, cy, rooms, total_rooms)) {
        draw_door(doorA_x, doorA_y);
        draw_door(doorB_x, doorB_y);
        draw_corridor(corridor_start_x, corridor_start_y, corridor_end_x, corridor_end_y, cy);
        return 1;
    }
    return 0;
}

// Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ØªØµØ§Ù„ Ú©Ø§Ù…Ù„ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
// Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ØªØµØ§Ù„ Ú©Ø§Ù…Ù„ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
void ensure_full_connectivity(Room rooms[], int total_rooms) {
    int visited[MAX_ROOMS] = {0};
    int stack[MAX_ROOMS];
    int stack_top = -1;

    // Ø´Ø±ÙˆØ¹ DFS Ø§Ø² Ø§ÙˆÙ„ÛŒÙ† Ø§ØªØ§Ù‚
    stack[++stack_top] = 0;
    visited[0] = 1;

    while (stack_top >= 0) {
        int current = stack[stack_top--];

        for (int i = 0; i < total_rooms; i++) {
            if (!visited[i] && connect_rooms(rooms[current], rooms[i], rooms, total_rooms)) {
                visited[i] = 1;
                stack[++stack_top] = i;
            }
        }
    }

    // Ø¨Ø±Ø±Ø³ÛŒ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯Ø§
    for (int i = 0; i < total_rooms; i++) {
        if (!visited[i]) {
            // Ø§ØªØµØ§Ù„ Ø§ØªØ§Ù‚ Ø¬Ø¯Ø§ Ø¨Ù‡ ÛŒÚ© Ø§ØªØ§Ù‚ ØªØµØ§Ø¯ÙÛŒ Ù…ØªØµÙ„
            for (int j = 0; j < total_rooms; j++) {
                if (visited[j]) {
                    connect_rooms(rooms[i], rooms[j], rooms, total_rooms);
                    visited[i] = 1;
                    break;
                }
            }
        }
    }
}


// Ù…ØªØºÛŒØ± Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø­Ø§Ù„Øª Ø­Ø±Ú©Øª
int waiting_for_direction = 0;
int move_direction_x = 0, move_direction_y = 0;

// ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø­Ø±Ú©Øª Ù…Ø¯Ø§ÙˆÙ… Ø¯Ø± Ø¬Ù‡Øª Ù…Ø´Ø®Øµ
void start_continuous_move(int x_dir, int y_dir) {
    move_direction_x = x_dir;
    move_direction_y = y_dir;
    waiting_for_direction = 0;  // Ù¾Ø§ÛŒØ§Ù† Ø­Ø§Ù„Øª Ø§Ù†ØªØ¸Ø§Ø±
}

void add_gold_bag_to_room(Room *room) {
    for (int i = 0; i < 1; i++) { // Add 1 gold bag per room
        int gold_bag_x, gold_bag_y;
        do {
            gold_bag_x = room->x + 1 + rand() % (room->width - 2);
            gold_bag_y = room->y + 1 + rand() % (room->height - 2);
        } while (map[gold_bag_y][gold_bag_x] == '&'); // Ensure we don't place gold bag on another gold bag

        map[gold_bag_y][gold_bag_x] = '&'; // Mark position of gold bag in map
        attron(COLOR_PAIR(2)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
        mvaddch(gold_bag_y, gold_bag_x, '&'); // Display gold bag on screen
        attroff(COLOR_PAIR(2)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

    }
}
void add_demons_to_rooms(Room *rooms, int room_count) {
    for (int i = 0; i < TOTAL_DEMONS; i++) {
        int room_index, attempts = 0;
        do {
            room_index = rand() % room_count;
            attempts++;
        } while (rooms[room_index].has_demon && attempts < 100);

        if (attempts >= 100) continue;

        Monster demon;
        do {
            demon.x = rooms[room_index].x + 1 + rand() % (rooms[room_index].width - 2);
            demon.y = rooms[room_index].y + 1 + rand() % (rooms[room_index].height - 2);
        } while (map[demon.y][demon.x] != '.');

        demon.hp = 5;
        demon.active = 0;
        demon.room_index = room_index;

        demons[demon_count++] = demon;
        map[demon.y][demon.x] = 'D';
        rooms[room_index].has_demon = 1;
    }
}

void add_undeads_to_rooms(Room *rooms, int room_count) {
    for (int i = 0; i < TOTAL_UNDEAD; i++) {
        int room_index, attempts = 0;
        do {
            room_index = rand() % room_count;
            attempts++;
        } while (rooms[room_index].has_undead && attempts < 100);

        if (attempts >= 100) continue;

        Monster undead;
        do {
            undead.x = rooms[room_index].x + 1 + rand() % (rooms[room_index].width - 2);
            undead.y = rooms[room_index].y + 1 + rand() % (rooms[room_index].height - 2);
        } while (map[undead.y][undead.x] != '.');

        undead.hp = 30;
        undead.active = 0;
        undead.room_index = room_index;
        undead.move_count = 0;

        undeads[undead_count++] = undead;
        map[undead.y][undead.x] = 'U';
        rooms[room_index].has_undead = 1;
    }
}

void add_giants_to_rooms(Room *rooms, int room_count) {
    for (int i = 0; i < TOTAL_GIANTS; i++) {
        int room_index, attempts = 0;
        do {
            room_index = rand() % room_count;
            attempts++;
        } while (rooms[room_index].has_giant && attempts < 100);

        if (attempts >= 100) continue;

        Monster giant;
        do {
            giant.x = rooms[room_index].x + 1 + rand() % (rooms[room_index].width - 2);
            giant.y = rooms[room_index].y + 1 + rand() % (rooms[room_index].height - 2);
        } while (map[giant.y][giant.x] != '.');

        giant.hp = 30;
        giant.active = 0;
        giant.room_index = room_index;
        giant.move_count = 0;

        giants[giant_count++] = giant;
        map[giant.y][giant.x] = 'G';
        rooms[room_index].has_giant = 1;
    }
}

void add_snakes_to_rooms(Room *rooms, int room_count) {
    for (int i = 0; i < TOTAL_SNAKES; i++) {
        int room_index, attempts = 0;
        do {
            room_index = rand() % room_count;
            attempts++;
        } while (rooms[room_index].has_snake && attempts < 100);

        if (attempts >= 100) continue;

        Monster snake;
        do {
            snake.x = rooms[room_index].x + 1 + rand() % (rooms[room_index].width - 2);
            snake.y = rooms[room_index].y + 1 + rand() % (rooms[room_index].height - 2);
        } while (map[snake.y][snake.x] != '.');

        snake.hp = 20;
        snake.active = 0;
        snake.room_index = room_index;

        snakes[snake_count++] = snake;
        map[snake.y][snake.x] = 'S';
        rooms[room_index].has_snake = 1;
    }
}

void add_firemonster_to_rooms(Room *rooms, int room_count) {
    for (int i = 0; i < TOTAL_FIRE; i++) {
        int room_index, attempts = 0;
        do {
            room_index = rand() % room_count;
            attempts++;
        } while (rooms[room_index].has_firemonster && attempts < 100);

        if (attempts >= 100) continue;

        Monster firemonster;
        do {
            firemonster.x = rooms[room_index].x + 1 + rand() % (rooms[room_index].width - 2);
            firemonster.y = rooms[room_index].y + 1 + rand() % (rooms[room_index].height - 2);
        } while (map[firemonster.y][firemonster.x] != '.');

        firemonster.hp = 10;
        firemonster.active = 0;
        firemonster.room_index = room_index;

        firemonsters[fire_count++] = firemonster;
        map[firemonster.y][firemonster.x] = 'F';
        rooms[room_index].has_firemonster = 1;
    }
}
void add_food_to_room(Room *room) {
    for (int i = 0; i < 1; i++) { // 33% Ø´Ø§Ù†Ø³ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø¯Ù† ØºØ°Ø§ Ø¯Ø± Ø§ØªØ§Ù‚
        int food_x, food_y;
        do {
            food_x = room->x + 1 + rand() % (room->width - 2);
            food_y = room->y + 1 + rand() % (room->height - 2);
        } while (map[food_y][food_x] == 'f'); // Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¯Ù… Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø±ÙˆÛŒ ØºØ°Ø§ Ø¯ÛŒÚ¯Ø±

        map[food_y][food_x] = 'f'; // Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ ØºØ°Ø§ Ø¯Ø± Ù†Ù‚Ø´Ù‡
        attron(COLOR_PAIR(6)); // Ø±Ù†Ú¯ ØºØ°Ø§ (Ø³Ø¨Ø²)
        mvaddch(food_y, food_x, 'f');
        attroff(COLOR_PAIR(6));
    }
}

//void show_status() {
//    mvprintw(1, 0, "â¤ï¸ Health: %d  ğŸ½ Hunger: %d  ğŸ Food: %d", player_hp, hunger, food_count);
//    refresh();
//}
//void add_food_to_inventory() {
//    if (food_count < 5) { // Ø­Ø¯Ø§Ú©Ø«Ø± Ûµ ÙˆØ§Ø­Ø¯ ØºØ°Ø§
//        food_count++;
//        mvprintw(0, 0, "You picked up ğŸ Food! Total: %d", food_count);
//    } else {
//        mvprintw(0, 0, "You can't carry more food!");
//    }
//    refresh();
//}
//void decrease_hunger() {
//    if (hunger > 0) {
//        hunger--;
//    } else {
//        player_hp -= 2; // Ø§Ú¯Ø± Ú¯Ø±Ø³Ù†Ú¯ÛŒ Ø¨Ù‡ Û° Ø¨Ø±Ø³Ø¯ØŒ Ø³Ù„Ø§Ù…Øª Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯
//        if (player_hp <= 0) {
//            mvprintw(0, 0, "You died from hunger! Game Over!");
//            refresh();
//            getch();
//            endwin();
//            exit(0);
//        }
//    }
//}
//void consume_food() {
//    if (food_count > 0) {
//        food_count--;
//        hunger += 20; // Ú©Ø§Ù‡Ø´ Ú¯Ø±Ø³Ù†Ú¯ÛŒ
//        if (hunger > 100) hunger = 100;
//        player_hp += 10; // Ø§ÙØ²Ø§ÛŒØ´ Ø³Ù„Ø§Ù…Øª
//        if (player_hp > 40) player_hp = 40;
//
//        mvprintw(0, 0, "You ate ğŸ Food! Health: %d, Hunger: %d", player_hp, hunger);
//    } else {
//        mvprintw(0, 0, "No food to eat!");
//    }
//    refresh();
//}
void add_mace_to_room(Room *room) {
    int mace_x, mace_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'M') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        mace_x = room->x + 1 + rand() % (room->width - 2);
        mace_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[mace_y][mace_x] == 'M'); // Ensure we don't place gold bag on another gold bag

    map[mace_y][mace_x] = 'M'; // Mark position of gold bag in map
    attron(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(mace_y, mace_x, 'M'); // Display gold bag on screen
    attroff(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}

void add_dagger_to_room(Room *room) {
    int dagger_x, dagger_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'D') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        dagger_x = room->x + 1 + rand() % (room->width - 2);
        dagger_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[dagger_y][dagger_x] == 'D'); // Ensure we don't place gold bag on another gold bag

    map[dagger_y][dagger_x] = 'D'; // Mark position of gold bag in map
    attron(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(dagger_y, dagger_x, 'D'); // Display gold bag on screen
    attroff(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}

void add_arrow_to_room(Room *room) {
    int arrow_x, arrow_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'A') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        arrow_x = room->x + 1 + rand() % (room->width - 2);
        arrow_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[arrow_y][arrow_x] == 'A'); // Ensure we don't place gold bag on another gold bag

    map[arrow_y][arrow_x] = 'A'; // Mark position of gold bag in map
    attron(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(arrow_y, arrow_x, 'A'); // Display gold bag on screen
    attroff(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}

void add_sword_to_room(Room *room) {
    int sword_x, sword_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'S') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        sword_x = room->x + 1 + rand() % (room->width - 2);
        sword_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[sword_y][sword_x] == 'S'); // Ensure we don't place gold bag on another gold bag

    map[sword_y][sword_x] = 'S'; // Mark position of gold bag in map
    attron(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(sword_y, sword_x, 'S'); // Display gold bag on screen
    attroff(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}

void add_wand_to_room(Room *room) {
    int wand_x, wand_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'W') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        wand_x = room->x + 1 + rand() % (room->width - 2);
        wand_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[wand_y][wand_x] == 'W'); // Ensure we don't place gold bag on another gold bag

    map[wand_y][wand_x] = 'W'; // Mark position of gold bag in map
    attron(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(wand_y, wand_x, 'W'); // Display gold bag on screen
    attroff(COLOR_PAIR(5)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}
void add_health_to_room(Room *room) {
    int sword_x, sword_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'h') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        sword_x = room->x + 1 + rand() % (room->width - 2);
        sword_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[sword_y][sword_x] == 'h'); // Ensure we don't place gold bag on another gold bag

    map[sword_y][sword_x] = 'h'; // Mark position of gold bag in map
    attron(COLOR_PAIR(6)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(sword_y, sword_x, 'h'); // Display gold bag on screen
    attroff(COLOR_PAIR(6)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}
void add_speed_to_room(Room *room) {
    int sword_x, sword_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 's') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        sword_x = room->x + 1 + rand() % (room->width - 2);
        sword_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[sword_y][sword_x] == 's'); // Ensure we don't place gold bag on another gold bag

    map[sword_y][sword_x] = 's'; // Mark position of gold bag in map
    attron(COLOR_PAIR(6)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(sword_y, sword_x, 's'); // Display gold bag on screen
    attroff(COLOR_PAIR(6)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}
void add_damage_to_room(Room *room) {
    int sword_x, sword_y;
    for (int y = 0; y < LINES; y++) {
        for (int x = 0; x < COLS; x++) {
            if (map[y][x] == 'd') {
                return; // A wand is already placed, exit the function
            }
        }
    }
    do {
        sword_x = room->x + 1 + rand() % (room->width - 2);
        sword_y = room->y + 1 + rand() % (room->height - 2);
    } while (map[sword_y][sword_x] == 'd'); // Ensure we don't place gold bag on another gold bag

    map[sword_y][sword_x] = 'd'; // Mark position of gold bag in map
    attron(COLOR_PAIR(6)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
    mvaddch(sword_y, sword_x, 'd'); // Display gold bag on screen
    attroff(COLOR_PAIR(6)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

}
void apply_spell_effects(GameState* game_state) {
    for (int i = 0; i < 3; i++) {
        if (active_spells[i].active) {
            active_spells[i].duration--;
            if (active_spells[i].duration <= 0) {
                active_spells[i].active = 0;
            }
        }
    }
}

void pick_up_spell(const char* spell_name) {
    for (int i = 0; i < 3; i++) {
        if (strcmp(active_spells[i].name, spell_name) == 0) {
            active_spells[i].duration = 10;  // Ù…Ø¯Øª Ø²Ù…Ø§Ù† Û±Û° Ø­Ø±Ú©Øª
            return;
        }
    }
}
void use_spell(GameState* game_state) {
    clear();
    mvprintw(2, 0, "ğŸ“¦ Your Spells:");
    int spell_count = 0;

    // Ù†Ù…Ø§ÛŒØ´ Ø·Ù„Ø³Ù…â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
    for (int i = 0; i < inventory_count; i++) {
        if (strcmp(inventory[i].type, "Spell") == 0) {
            mvprintw(4 + spell_count, 0, "[%d] %s", spell_count + 1, inventory[i].name);
            spell_count++;
        }
    }

    if (spell_count == 0) {
        mvprintw(4, 0, "âŒ You have no spells!");
        refresh();
        sleep(1);
        return;
    }

    mvprintw(6 + spell_count, 0, "Press 1-%d to use a spell or any other key to exit.", spell_count);
    refresh();

    int key = getch() - '1'; // Ù…Ù‚Ø¯Ø§Ø± ÙˆØ±ÙˆØ¯ÛŒ Ø±Ø§ ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Û° ØªØ§ n Ù…ÛŒâ€ŒÚ©Ù†Ø¯
    if (key >= 0 && key < spell_count) {
        // ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø·Ù„Ø³Ù…
        strcpy(active_spells[key].name, inventory[key].name);
        active_spells[key].duration = 10;
        active_spells[key].active = 1;

        // Ø­Ø°Ù Ø·Ù„Ø³Ù… Ø§Ø² Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ Ø¨Ø¹Ø¯ Ø§Ø² Ø§Ø³ØªÙØ§Ø¯Ù‡
        for (int j = key; j < inventory_count - 1; j++) {
            inventory[j] = inventory[j + 1];
        }
        inventory_count--;

        mvprintw(8 + spell_count, 0, "âœ… You used %s!", active_spells[key].name);
        refresh();
        sleep(1);
    }
}
void add_black_gold_to_room(Room *room, int *black_gold_room_count) {
    // ÙÙ‚Ø· Ø§Ú¯Ø± ØªØ¹Ø¯Ø§Ø¯ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø±Ø§ÛŒ Ø·Ù„Ø§ÛŒ Ø³ÛŒØ§Ù‡ Ú©Ù…ØªØ± Ø§Ø² 2 Ø¨Ø§Ø´Ø¯ØŒ Ø·Ù„Ø§ÛŒ Ø³ÛŒØ§Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
    if (*black_gold_room_count < 2) {
        int black_gold_x, black_gold_y;
        do {
            black_gold_x = room->x + 1 + rand() % (room->width - 2);
            black_gold_y = room->y + 1 + rand() % (room->height - 2);
        } while (map[black_gold_y][black_gold_x] == 'B'); // Ensure we don't place black gold on another black gold

        map[black_gold_y][black_gold_x] = 'B'; // Place black gold in the map
        attron(COLOR_PAIR(4)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§
        mvaddch(black_gold_y, black_gold_x, 'B'); // Display black gold on screen
        attroff(COLOR_PAIR(4)); // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ù†Ú¯ Ù‚Ø±Ù…Ø² Ø¨Ø±Ø§ÛŒ ØªÙ„Ù‡â€ŒÙ‡Ø§

        (*black_gold_room_count)++; // Ø§ÙØ²Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø±Ø§ÛŒ Ø·Ù„Ø§ÛŒ Ø³ÛŒØ§Ù‡
    }
}
void play_background_music(const char *music) {
    if (fork() == 0) { // Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ±Ø²Ù†Ø¯ Ø¨Ø±Ø§ÛŒ Ù¾Ø®Ø´ Ø¢Ù‡Ù†Ú¯ Ø¨Ø¯ÙˆÙ† ØªÙˆÙ‚Ù Ø¨Ø§Ø²ÛŒ
        execlp("afplay", "afplay", music, NULL);
        exit(0);
    }
}
void add_to_inventory(const char* item_name, const char* item_type) {
    for (int i = 0; i < inventory_count; i++) {
        if (strcmp(inventory[i].name, item_name) == 0 && strcmp(inventory[i].type, item_type) == 0) {
            return; // Ø¢ÛŒØªÙ… Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯
        }
    }

    if (inventory_count < MAX_INVENTORY_ITEMS) {
        strncpy(inventory[inventory_count].name, item_name, ITEM_NAME_LENGTH - 1);
        strncpy(inventory[inventory_count].type, item_type, ITEM_NAME_LENGTH - 1);
        inventory_count++;

        // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ø¨Ø±Ø¯Ø§Ø´ØªÙ† Ø¢ÛŒØªÙ… Ù‡Ù…Ø±Ø§Ù‡ Ø¨Ø§ Ø§Ø³ØªÛŒÚ©Ø± ØµØ­ÛŒØ­
        const char* icon = "";
        if (strcmp(item_name, "Mace") == 0) icon = MACE_ICON;
        else if (strcmp(item_name, "Dagger") == 0) icon = DAGGER_ICON;
        else if (strcmp(item_name, "Wand") == 0) icon = WAND_ICON;
        else if (strcmp(item_name, "Arrow") == 0) icon = ARROW_ICON;
        else if (strcmp(item_name, "Sword") == 0) icon = SWORD_ICON;

        snprintf(current_message, sizeof(current_message), "You picked up %s %s", icon, item_name);
        mvprintw(0, 0, current_message); // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ø¯Ø± Ø¨Ø§Ù„Ø§ÛŒ ØµÙØ­Ù‡
        refresh();
    }
}

void show_inventory() {
    int start_x = COLS - 35; // Ù…ÙˆÙ‚Ø¹ÛŒØª Ù†Ù…Ø§ÛŒØ´ Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
    int start_y = 2;
    int height = 20; // Ø§Ø±ØªÙØ§Ø¹ ØªÙ‚Ø±ÛŒØ¨ÛŒ Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ

    // âœ… Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù†Ø§Ø­ÛŒÙ‡ Ù†Ù…Ø§ÛŒØ´
    for (int i = 0; i < height; i++) {
        move(start_y + i - 2, start_x - 2);
        clrtoeol();
    }

    // âœ… Ù‚Ø§Ø¨ Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
    attron(COLOR_PAIR(3));
    mvprintw(start_y - 2, start_x - 2, "+--------------------------------+");
    mvprintw(start_y + height - 2, start_x - 2, "+--------------------------------+");
    attroff(COLOR_PAIR(3));

    // âœ… Ø¹Ù†ÙˆØ§Ù† Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
    attron(A_BOLD);
    mvprintw(start_y, start_x, "ğŸ“¦ INVENTORY");
    attroff(A_BOLD);

    // âœ… Ù†Ù…Ø§ÛŒØ´ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø³Ù„Ø§Ø­â€ŒÙ‡Ø§
    mvprintw(start_y + 2, start_x, "ğŸ”« Weapons:");
    int weapon_count = 0;
    int weapon_indices[MAX_INVENTORY_ITEMS];
    static char equipped_weapon[ITEM_NAME_LENGTH] = "None";  // Ø³Ù„Ø§Ø­ Ù…Ø¬Ù‡Ø² Ø´Ø¯Ù‡

    for (int i = 0; i < inventory_count; i++) {
        if (strcmp(inventory[i].type, "Weapon") == 0) {
            const char* icon = "";
            if (strcmp(inventory[i].name, "Mace") == 0) icon = MACE_ICON;
            else if (strcmp(inventory[i].name, "Dagger") == 0) icon = DAGGER_ICON;
            else if (strcmp(inventory[i].name, "Wand") == 0) icon = WAND_ICON;
            else if (strcmp(inventory[i].name, "Arrow") == 0) icon = ARROW_ICON;
            else if (strcmp(inventory[i].name, "Sword") == 0) icon = SWORD_ICON;

            mvprintw(start_y + 3 + weapon_count, start_x, "[%d] %s %s", weapon_count + 1, icon, inventory[i].name);
            weapon_indices[weapon_count] = i;
            weapon_count++;
        }
    }
    if (weapon_count == 0) mvprintw(start_y + 3, start_x, "No weapons.");

    // âœ… Ù†Ù…Ø§ÛŒØ´ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø·Ù„Ø³Ù…â€ŒÙ‡Ø§
    int spell_start = start_y + 4 + weapon_count;
    mvhline(spell_start, start_x, '-', 30);
    mvprintw(spell_start + 1, start_x, "ğŸª„ Spells:");
    int spell_count = 0;
    int spell_indices[MAX_INVENTORY_ITEMS];

    for (int i = 0; i < inventory_count; i++) {
        if (strcmp(inventory[i].type, "Spell") == 0) {
            const char* spell_icon = "";
            if (strcmp(inventory[i].name, "Speed") == 0) spell_icon = speed_ICON;
            else if (strcmp(inventory[i].name, "Health") == 0) spell_icon = health_ICON;
            else if (strcmp(inventory[i].name, "Damage") == 0) spell_icon = damage_ICON;

            mvprintw(spell_start + 2 + spell_count, start_x, "[%d] %s %s", spell_count + 1, spell_icon, inventory[i].name);
            spell_indices[spell_count] = i;
            spell_count++;
        }
    }
    if (spell_count == 0) mvprintw(spell_start + 2, start_x, "No spells.");

    // âœ… Ù†Ù…Ø§ÛŒØ´ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØºØ°Ø§ Ùˆ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø®Ø±ÙˆØ¬
    int food_start = spell_start + 3 + spell_count;
    mvhline(food_start, start_x, '-', 30);
    mvprintw(food_start + 1, start_x, "ğŸ Food: %d", food_count);
    mvprintw(food_start + 2, start_x, "ğŸ›¡ Equipped Weapon: %s", equipped_weapon);
    mvprintw(food_start + 3, start_x, "[1-%d] Equip Weapon  |  [T] Use Spell", weapon_count);
    mvprintw(food_start + 4, start_x, "[E] Eat  |  [I] Exit");

    refresh();

    // âœ… Ú©Ù†ØªØ±Ù„ ÙˆØ±ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¹Ø§Ù…Ù„ Ø¨Ø§ Inventory
    int key;
    while ((key = getch()) != 'i') {
        if (key >= '1' && key <= '0' + weapon_count) {
            int selected_index = key - '1'; // ØªØ¨Ø¯ÛŒÙ„ Ø¹Ø¯Ø¯ ÙˆØ±ÙˆØ¯ÛŒ Ø¨Ù‡ Ø§ÛŒÙ†Ø¯Ú©Ø³
            strcpy(equipped_weapon, inventory[weapon_indices[selected_index]].name);
            mvprintw(food_start + 2, start_x, "ğŸ›¡ Equipped Weapon: %s      ", equipped_weapon);
            refresh();
        } else if (key == 't' && spell_count > 0) {
            mvprintw(food_start + 5, start_x, "Press [1-%d] to use a spell!", spell_count);
            refresh();
            int spell_key = getch();
            if (spell_key >= '1' && spell_key <= '0' + spell_count) {
                int selected_spell = spell_key - '1';
                snprintf(current_message, sizeof(current_message), "You used %s!", inventory[spell_indices[selected_spell]].name);
                mvprintw(food_start + 6, start_x, "ğŸª„ %s activated!", inventory[spell_indices[selected_spell]].name);
                refresh();
                sleep(1);
            }
        } else if (key == 'e') {
            if (food_count > 0) {
                food_count--;
                hunger += 20;
                if (hunger > 100) hunger = 100;
                player_hp += 10;
                if (player_hp > 40) player_hp = 40;
                mvprintw(food_start + 5, start_x, "ğŸ½ You ate! HP: %d, Hunger: %d", player_hp, hunger);
            } else {
                mvprintw(food_start + 5, start_x, "ğŸš« No food left!");
            }
            refresh();
        }
    }

    // âœ… Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ú©Ù„ Ù†Ø§Ø­ÛŒÙ‡ Ø¨Ø¹Ø¯ Ø§Ø² Ø®Ø±ÙˆØ¬
    for (int i = 0; i < height; i++) {
        move(start_y + i - 2, start_x - 2);
        clrtoeol();
    }
    refresh();
}
char save_message[100] = "";  // Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ§Ù… Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ
int save_message_counter = 0; // Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø­Ø°Ù Ù¾ÛŒØ§Ù…
void save_game(const char* filename, GameState* game_state) {
    FILE *file = fopen(filename, "wb");
    if (file) {
        // Ø°Ø®ÛŒØ±Ù‡ Ù†Ù‚Ø´Ù‡ Ù‚Ø¨Ù„ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ
        memcpy(game_state->map, map, sizeof(map));

        fwrite(game_state, sizeof(GameState), 1, file);
        fclose(file);

        strcpy(save_message, "âœ… Game saved successfully!");
        save_message_counter = 3;
    } else {
        strcpy(save_message, "âŒ Error: Unable to save the game!");
        save_message_counter = 3;
    }
}
int load_game(const char* filename, GameState* game_state) {
    FILE *file = fopen(filename, "rb");
    if (file) {
        fread(game_state, sizeof(GameState), 1, file);
        fclose(file);

        // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ù†Ù‚Ø´Ù‡ Ø¯Ø± Ø­Ø§ÙØ¸Ù‡
        memcpy(map, game_state->map, sizeof(map));

        // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØµÙØ­Ù‡ Ùˆ Ø±Ø³Ù… Ù…Ø¬Ø¯Ø¯
        clear();

        // Ø±Ø³Ù… Ù…Ø¬Ø¯Ø¯ Ø§ØªØ§Ù‚â€ŒÙ‡Ø§
        for (int i = 0; i < MAX_ROOMS; i++) {
            draw_room(game_state->rooms[i], game_state->rooms, MAX_ROOMS);
        }

        // Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒÚ©Ù†
        player_hp = game_state->player_hp;
        hunger = game_state->hunger;
        food_count = game_state->food_count;
        gold_count = game_state->gold_count;
        inventory_count = game_state->inventory_count;
        memcpy(inventory, game_state->inventory, sizeof(inventory));

        // Ù†Ù…Ø§ÛŒØ´ Ù†Ù‚Ø´Ù‡ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡
        for (int i = 0; i < LINES; i++) {
            for (int j = 0; j < COLS; j++) {
                if (map[i][j] != ' ') {
                    mvaddch(i, j, map[i][j]);
                }
            }
        }

        mvprintw(0, 0, "âœ… Game loaded successfully!");
        refresh();
        return 1;
    } else {
        mvprintw(0, 0, "âŒ Error: Unable to load the game!");
        return 0;
    }
}
void add_save_file_to_list(const char* filename) {
    FILE *file = fopen("save_list.txt", "a");
    if (file) {
        fprintf(file, "%s\n", filename);
        fclose(file);
    }
}
void load_save_list() {
    FILE *file = fopen("save_list.txt", "r");
    if (file) {
        char line[50];
        printw("ğŸ“‚ Saved games:\n");
        while (fgets(line, sizeof(line), file)) {
            printw("%s", line);
        }
        fclose(file);
    } else {
        printw("âš ï¸ No saved games found!\n");
    }
    refresh();
}
void move_demon(Monster *demon) {
    if (!demon->active) return; // Ø§Ú¯Ø± ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª Ø­Ø±Ú©Øª Ù†Ú©Ù†Ø¯

    int dx = (rand() % 3) - 1; // Ø­Ø±Ú©Øª ØªØµØ§Ø¯ÙÛŒ Ø¯Ø± Ø¬Ù‡Øª x (-1, 0, 1)
    int dy = (rand() % 3) - 1; // Ø­Ø±Ú©Øª ØªØµØ§Ø¯ÙÛŒ Ø¯Ø± Ø¬Ù‡Øª y (-1, 0, 1)

    int new_x = demon->x + dx;
    int new_y = demon->y + dy;

    // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø­Ø±Ú©Øª Ø¨Ù‡ ÛŒÚ© Ù…Ú©Ø§Ù† Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯
    chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
    if (next_cell == '.' || next_cell == '#' || next_cell == '+') {
        mvaddch(demon->y, demon->x, '.'); // Ø¬Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ Ø±Ø§ Ù¾Ø§Ú© Ú©Ù†
        demon->x = new_x;
        demon->y = new_y;
        mvaddch(demon->y, demon->x, 'D'); // Ø¬Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¨Ø¯Ù‡
    }
}

void move_undead(Monster *undead) {
    if (!undead->active) return;

    int dx = (rand() % 3) - 1;
    int dy = (rand() % 3) - 1;

    int new_x = undead->x + dx;
    int new_y = undead->y + dy;

    chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
    if (next_cell == '.' || next_cell == '#' || next_cell == '+') {
        mvaddch(undead->y, undead->x, '.');
        undead->x = new_x;
        undead->y = new_y;
        mvaddch(undead->y, undead->x, 'U');
    }
}

void move_giant(Monster *giant) {
    if (!giant->active) return;

    int dx = (rand() % 3) - 1;
    int dy = (rand() % 3) - 1;

    int new_x = giant->x + dx;
    int new_y = giant->y + dy;

    chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
    if (next_cell == '.' || next_cell == '#' || next_cell == '+') {
        mvaddch(giant->y, giant->x, '.');
        giant->x = new_x;
        giant->y = new_y;
        mvaddch(giant->y, giant->x, 'G');
    }
}

void move_snake(Monster *snake) {
    if (!snake->active) return;

    int dx = (rand() % 3) - 1;
    int dy = (rand() % 3) - 1;

    int new_x = snake->x + dx;
    int new_y = snake->y + dy;

    chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
    if (next_cell == '.' || next_cell == '#' || next_cell == '+') {
        mvaddch(snake->y, snake->x, '.');
        snake->x = new_x;
        snake->y = new_y;
        mvaddch(snake->y, snake->x, 'S');
    }
}

void move_firemonster(Monster *firemonster) {
    if (!firemonster->active) return;

    int dx = (rand() % 3) - 1;
    int dy = (rand() % 3) - 1;

    int new_x = firemonster->x + dx;
    int new_y = firemonster->y + dy;

    chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
    if (next_cell == '.' || next_cell == '#' || next_cell == '+') {
        mvaddch(firemonster->y, firemonster->x, '.');
        firemonster->x = new_x;
        firemonster->y = new_y;
        mvaddch(firemonster->y, firemonster->x, 'F');
    }
}
// ØªØºÛŒÛŒØ± Ø¯Ø± ØªØ§Ø¨Ø¹ move_character
void move_character(int *x, int *y, char *prev_cell, GameState *game_state) {
    int ch = getch();
    int new_x = *x, new_y = *y;

    // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
    mvprintw(0, 0, "                                           ");
    strcpy(gold_message, "");

    if (waiting_for_direction) {
        switch (ch) {
            case 'h': start_continuous_move(-1, 0); break; // Ú†Ù¾
            case 'j': start_continuous_move(0, 1); break;  // Ù¾Ø§ÛŒÛŒÙ†
            case 'k': start_continuous_move(0, -1); break; // Ø¨Ø§Ù„Ø§
            case 'l': start_continuous_move(1, 0); break;  // Ø±Ø§Ø³Øª
        }
    } else {
        // Ø­Ø±Ú©Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ø¬Ù‡Øª
        switch (ch) {
            case 'j':    new_y--; break; // Ù¾Ø§ÛŒÛŒÙ†
            case 'k':  new_y++; break;  // Ø¨Ø§Ù„Ø§
            case 'h':  new_x--; break;  // Ú†Ù¾
            case 'l': new_x++; break;  // Ø±Ø§Ø³Øª
            case 'y': new_x--; new_y--; break; // Ø¨Ø§Ù„Ø§ Ú†Ù¾
            case 'u': new_x++; new_y--; break; // Ø¨Ø§Ù„Ø§ Ø±Ø§Ø³Øª
            case 'b': new_x--; new_y++; break; // Ù¾Ø§ÛŒÛŒÙ† Ú†Ù¾
            case 'n': new_x++; new_y++; break; // Ù¾Ø§ÛŒÛŒÙ† Ø±Ø§Ø³Øª
            case 'i': show_inventory(); break;
            case 't': // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø·Ù„Ø³Ù…
                use_spell(game_state);
                break;
            case 'f': waiting_for_direction = 1; break; // Ø´Ø±ÙˆØ¹ Ø­Ø±Ú©Øª Ù…Ø¯Ø§ÙˆÙ…
            case 's': // Ø°Ø®ÛŒØ±Ù‡â€ŒÛŒ Ø¨Ø§Ø²ÛŒ Ø¨Ø¹Ø¯ Ø§Ø² ØªØ§ÛŒÛŒØ¯
                mvprintw(0, 0, "ğŸ’¾ Save game? (y/n): ");
                refresh();
                int confirm = getch();
                if (confirm == 'y') {
                    // ğŸ“Œ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù‚Ø¨Ù„ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡
                    game_state->player_x = *x;
                    game_state->player_y = *y;
                    game_state->player_hp = player_hp;
                    game_state->hunger = hunger;
                    game_state->food_count = food_count;
                    game_state->gold_count = gold_count;
                    game_state->inventory_count = inventory_count;
                    memcpy(game_state->inventory, inventory, sizeof(inventory));

                    save_game("save1.dat", game_state);
                    add_save_file_to_list("save1.dat");
                } else {
                    mvprintw(0, 0, "âŒ Save canceled.");
                    mvprintw(0, 0, gold_message);

                }
        }
    }
    if (active_spells[1].active) {
        game_state->speed_move_counter++;
        if (game_state->speed_move_counter % 2 == 0) {
            game_state->hunger--; // Ú©Ø§Ù‡Ø´ Ú¯Ø±Ø³Ù†Ú¯ÛŒ Ù‡Ù†Ú¯Ø§Ù… Ø­Ø±Ú©Øª Ø³Ø±ÛŒØ¹
        }

        // Ø­Ø±Ú©Øª Ø§Ø¶Ø§ÙÙ‡ Ø¯Ø± Ù‡Ù…Ø§Ù† Ø¬Ù‡Øª
        int speed_x = new_x + (new_x - *x);
        int speed_y = new_y + (new_y - *y);

        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ù…Ú©Ø§Ù† Ø¬Ø¯ÛŒØ¯ Ù…Ø¬Ø§Ø² Ø§Ø³Øª
        chtype speed_next_cell = mvinch(speed_y, speed_x) & A_CHARTEXT;
        if (speed_next_cell == '.' || speed_next_cell == '#' || speed_next_cell == '+') {
            mvaddch(*y, *x, *prev_cell); // Ø­Ø°Ù Ø¬Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
            *prev_cell = speed_next_cell;
            *x = speed_x;
            *y = speed_y;
            mvaddch(*y, *x, '@'); // Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¯Ø± Ù…Ú©Ø§Ù† Ø¬Ø¯ÛŒØ¯
        }
    } else {
        // Ø­Ø±Ú©Øª Ù…Ø¹Ù…ÙˆÙ„ÛŒ
        chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
        if (next_cell == '.' || next_cell == '#' || next_cell == '+') {
            mvaddch(*y, *x, *prev_cell); // Ø­Ø°Ù Ø¬Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
            *prev_cell = next_cell;
            *x = new_x;
            *y = new_y;
            mvaddch(*y, *x, '@'); // Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¯Ø± Ù…Ú©Ø§Ù† Ø¬Ø¯ÛŒØ¯
        }
    }

    // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Speed
    if (active_spells[1].active) {
        active_spells[1].duration--;
        if (active_spells[1].duration <= 0) {
            active_spells[1].active = 0; // ØºÛŒØ±ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø·Ù„Ø³Ù…
        }
    }

    chtype next_cell = mvinch(new_y, new_x) & A_CHARTEXT;
    if (save_message_counter > 0) {
        mvprintw(0, 0, "%s", save_message);
        save_message_counter--;

        // Ø§Ú¯Ø± Ø´Ù…Ø§Ø±Ø´ Ø¨Ù‡ ØµÙØ± Ø±Ø³ÛŒØ¯ØŒ Ù¾ÛŒØ§Ù… Ø­Ø°Ù Ø´ÙˆØ¯
        if (save_message_counter == 0) {
            strcpy(save_message, "");
            mvprintw(0, 0, "                                    ");  // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù…ØªÙ†
        }
    } else {
        mvprintw(0, 0, "                                    ");  // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ù‚Ø¨Ù„ÛŒ
    }
    //  Ø§Ú¯Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† Ø±ÙˆÛŒ ØºØ°Ø§ Ø¨Ø±ÙˆØ¯
    if (next_cell == 'f') {
        if (food_count < 5) {  // ÙÙ‚Ø· Ø§Ú¯Ø± Ú©Ù…ØªØ± Ø§Ø² 5 ØºØ°Ø§ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒÙ…
            food_count++;
            mvprintw(0, 0, "You picked up ğŸ Food! Total: %d", food_count);
            mvaddch(new_y, new_x, '.'); // Ø­Ø°Ù ØºØ°Ø§ Ø§Ø² Ù†Ù‚Ø´Ù‡
            next_cell = '.';
        } else {
            mvprintw(0, 0, "You can't carry more food!");
        }
        refresh();
    }

    if (active_spells[1].active)
    {  // Ø§Ú¯Ø± Speed ÙØ¹Ø§Ù„ Ø§Ø³Øª
        game_state->speed_move_counter++;
        if (game_state->speed_move_counter % 2 == 0) {
            game_state->hunger--;  // Ù‡Ø± Ø¯Ùˆ Ø­Ø±Ú©ØªØŒ ÛŒÚ© ÙˆØ§Ø­Ø¯ Ú¯Ø±Ø³Ù†Ú¯ÛŒ Ú©Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯
        }
    } else {
        game_state->hunger--;  // Ú¯Ø±Ø³Ù†Ú¯ÛŒ Ø¨Ù‡ Ø·ÙˆØ± Ù…Ø¹Ù…ÙˆÙ„ Ú©Ø§Ù‡Ø´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯
    }

    // Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø«Ø±Ø§Øª Ø·Ù„Ø³Ù…â€ŒÙ‡Ø§
    apply_spell_effects(game_state);

    if (ch == 'q') {  // Ø¯Ø± ØµÙˆØ±Øª ÙØ´Ø§Ø± Ø¯Ø§Ø¯Ù† q
        mvprintw(0, 0, " Do you want to return to menu? (r/n): ");
        refresh();
        int confirm = getch();
        if (confirm == 'r') {
            endwin(); // Ø¨Ø³ØªÙ† ncurses
            return; // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ù¾ÛŒØ´ Ø§Ø² Ø¨Ø§Ø²ÛŒ
        } else {
            mvprintw(0, 0, "Game continues...");
            refresh();
        }
        return;
    }
    // Ø·Ù„Ø§ÛŒ Ù…Ø¹Ù…ÙˆÙ„ÛŒ
    if (next_cell == '&') {
        mvaddch(new_y, new_x, '.');
        next_cell = '.';
        gold_count++;
        strcpy(gold_message, "You collected ğŸ’°!");
        mvprintw(0, 0, gold_message);
        refresh();
    }

    // Ø·Ù„Ø§ÛŒ Ø³ÛŒØ§Ù‡
    if (next_cell == 'B') {
        mvaddch(new_y, new_x, '.');
        next_cell = '.';
    }

    // ØªÙ„Ù‡
    if (next_cell == 'T') {
        mvaddch(new_y, new_x, '^');
        next_cell = '^';
        player_hp--;

    }

    // Ø­Ø±Ú©Øª Ø¯Ø± Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ Ù…Ø¬Ø§Ø²
    if (next_cell == '.' || next_cell == '#' || next_cell == '+' || next_cell == '^' ||
        next_cell == 'M' || next_cell == 'S' || next_cell == 'D' || next_cell == 'A' || next_cell == 'W' ||
        next_cell == 'h' || next_cell == 'd' ||next_cell == 's' ) {
        mvaddch(*y, *x, *prev_cell); // Ø­Ø°Ù Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø¨Ù„ÛŒ
        *prev_cell = next_cell;
        *x = new_x;
        *y = new_y;
        mvaddch(*y, *x, '@'); // Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯
    }


    // Ø³Ù„Ø§Ø­â€ŒÙ‡Ø§ (Ø§Ù†ØªØ®Ø§Ø¨ÛŒ)
    if (next_cell == 'M' || next_cell == 'S' || next_cell == 'D' || next_cell == 'A' || next_cell == 'W') {
        char weapon_name[ITEM_NAME_LENGTH];
        char weapon_icon[10];

        switch (next_cell) {
            case 'M': strcpy(weapon_name, "Mace"); strcpy(weapon_icon, MACE_ICON); break;
            case 'S': strcpy(weapon_name, "Sword"); strcpy(weapon_icon, SWORD_ICON); break;
            case 'D': strcpy(weapon_name, "Dagger"); strcpy(weapon_icon, DAGGER_ICON); break;
            case 'A': strcpy(weapon_name, "Arrow"); strcpy(weapon_icon, ARROW_ICON); break;
            case 'W': strcpy(weapon_name, "Wand"); strcpy(weapon_icon, WAND_ICON); break;
        }

        // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø¯Ø§Ø´ØªÙ† Ø³Ù„Ø§Ø­
        mvprintw(0, 0, "Press 'r' to pick up %s %s", weapon_icon, weapon_name);
        refresh();

        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ù„ÛŒØ¯ `y` Ø¯Ø± Ø­Ø±Ú©Øª Ø¨Ø¹Ø¯ÛŒ ÙØ´Ø±Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª ÛŒØ§ Ø®ÛŒØ±
        int key = getch();
        if (key == 'r') {
            add_to_inventory(weapon_name, "Weapon");
            mvaddch(new_y, new_x, '.'); // Ø­Ø°Ù Ø³Ù„Ø§Ø­ Ø§Ø² Ù†Ù‚Ø´Ù‡
            next_cell = '.';
            refresh();
        }
    }

    if (next_cell == 'd' || next_cell == 's' || next_cell == 'h') {
        char spell_name[ITEM_NAME_LENGTH];
        char spell_icon[20];

        switch (next_cell) {
            case 's': strcpy(spell_name, "speed"); strcpy(spell_icon, speed_ICON); break;
            case 'h': strcpy(spell_name, "health"); strcpy(spell_icon, health_ICON); break;
            case 'd': strcpy(spell_name, "damage"); strcpy(spell_icon, damage_ICON); break;
        }

        // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø¯Ø§Ø´ØªÙ† Ø³Ù„Ø§Ø­
        mvprintw(0, 0, "Press 'r' to pick up %s %s", spell_icon, spell_name);
        refresh();

        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ù„ÛŒØ¯ `y` Ø¯Ø± Ø­Ø±Ú©Øª Ø¨Ø¹Ø¯ÛŒ ÙØ´Ø±Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø³Øª ÛŒØ§ Ø®ÛŒØ±
        int key = getch();
        if (key == 'r') {
            add_to_inventory(spell_name, "Spell");
            mvaddch(new_y, new_x, '.'); // Ø­Ø°Ù Ø³Ù„Ø§Ø­ Ø§Ø² Ù†Ù‚Ø´Ù‡
            next_cell = '.';
            refresh();
        }
    }

    // Ø­Ø±Ú©Øª Ø¯Ø± Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ Ù…Ø¬Ø§Ø²
    if (next_cell == '.' || next_cell == '#' || next_cell == '+' || next_cell == '^' ||
        next_cell == 'M' || next_cell == 'S' || next_cell == 'D' || next_cell == 'A' || next_cell == 'W' ||
        next_cell == 'h' || next_cell == 'd' ||next_cell == 's' ) {
        mvaddch(*y, *x, *prev_cell); // Ø­Ø°Ù Ù…ÙˆÙ‚Ø¹ÛŒØª Ù‚Ø¨Ù„ÛŒ
        *prev_cell = next_cell;
        *x = new_x;
        *y = new_y;
        mvaddch(*y, *x, '@'); // Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ø§Ú©ØªØ± Ø¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯
    }
}
void show_gold_count() {
    mvprintw(1, 0, "\xF0\x9F\x92\xB0: %d ", gold_count); // Ù†Ù…Ø§Ø¯ Ø·Ù„Ø§
    refresh();
}

void start_game() {
    setlocale(LC_ALL, ""); // ØªÙ†Ø¸ÛŒÙ… Ù…Ø­Ù„ Ø¨Ø±Ø§ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² ÛŒÙˆÙ†ÛŒÚ©Ø¯
    play_background_music(background_music); // Ù¾Ø®Ø´ Ø¢Ù‡Ù†Ú¯ Ø¯Ø± Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡

    srand(time(NULL));
    initscr();
    clear(); // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† clear() Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ù…Ù†ÙˆÛŒ Ù‚Ø¨Ù„ Ø§Ø² Ø¨Ø§Ø²ÛŒ
    refresh(); // Ø§Ø¹Ù…Ø§Ù„ ØªØºÛŒÛŒØ±Ø§Øª Ø¯Ø± ncurses

    noecho();
    cbreak();
    keypad(stdscr, TRUE);
    start_color(); // ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø±Ù†Ú¯â€ŒÙ‡Ø§

    init_pair(1, COLOR_RED, COLOR_BLACK);
    init_pair(2, COLOR_YELLOW, COLOR_BLACK);
    init_pair(3, COLOR_CYAN, COLOR_BLACK);
    init_pair(4, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(5, COLOR_BLUE, COLOR_BLACK);
    init_pair(6, COLOR_GREEN, COLOR_BLACK);

    bkgd(COLOR_BLACK);  // ØªÙ†Ø¸ÛŒÙ… Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø¨Ù‡ Ù…Ø´Ú©ÛŒ

    initialize_trap_map();
    Room rooms[MAX_ROOMS];
    create_rooms(rooms, MAX_ROOMS);
    int black_gold_room_count = 0;

    for (int i = 0; i < MAX_ROOMS; i++) {
        draw_room(rooms[i], rooms, MAX_ROOMS);
        add_pillars(rooms[i]);
        place_window_in_room(&rooms[i], rooms, MAX_ROOMS);
        add_traps_to_room(&rooms[i]);
        add_gold_bag_to_room(&rooms[i]);
        add_black_gold_to_room(&rooms[i], &black_gold_room_count);
        add_mace_to_room(&rooms[i]);
        add_dagger_to_room(&rooms[i]);
        add_wand_to_room(&rooms[i]);
        add_arrow_to_room(&rooms[i]);
        add_sword_to_room(&rooms[i]);
        add_damage_to_room(&rooms[i]);
        add_health_to_room(&rooms[i]);
        add_speed_to_room(&rooms[i]);
        add_food_to_room(&rooms[i]);

    }
    player_hp = 40;   // ØªÙ†Ø¸ÛŒÙ… Ù…Ù‚Ø¯Ø§Ø± Ø§ÙˆÙ„ÛŒÙ‡ Ø³Ù„Ø§Ù…ØªÛŒ
    hunger = 60;      // ØªÙ†Ø¸ÛŒÙ… Ù…Ù‚Ø¯Ø§Ø± Ø§ÙˆÙ„ÛŒÙ‡ Ú¯Ø±Ø³Ù†Ú¯ÛŒ
    food_count = 0;   // Ù…Ù‚Ø¯Ø§Ø± Ø§ÙˆÙ„ÛŒÙ‡ ØºØ°Ø§ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†
    gold_count = 0;   // Ù…Ù‚Ø¯Ø§Ø± Ø§ÙˆÙ„ÛŒÙ‡ Ø·Ù„Ø§
    inventory_count = 0; // Ù„ÛŒ Ú©Ø±Ø¯Ù† Ø§ÛŒÙ†ÙˆÙ†ØªÙˆØ±ÛŒ
//    add_demons_to_rooms(rooms, MAX_ROOMS);
//    add_undeads_to_rooms(rooms, MAX_ROOMS);
//    add_giants_to_rooms(rooms, MAX_ROOMS);
//    add_snakes_to_rooms(rooms, MAX_ROOMS);
//    add_firemonster_to_rooms(rooms, MAX_ROOMS);

    ensure_full_connectivity(rooms, MAX_ROOMS);

    int player_x = rooms[0].x + 1;
    int player_y = rooms[0].y + 1;
    char prev_cell = '.';
    mvaddch(player_y, player_x, '@');

    GameState game_state;
    game_state.player_x = player_x;
    game_state.player_y = player_y;
    game_state.player_hp = player_hp;
    game_state.hunger = hunger;
    game_state.food_count = food_count;
    game_state.gold_count = gold_count;
    game_state.inventory_count = inventory_count;
    memcpy(game_state.inventory, inventory, sizeof(inventory));
    memcpy(game_state.map, map, sizeof(map));  // Ø°Ø®ÛŒØ±Ù‡ Ù†Ù‚Ø´Ù‡
    memcpy(game_state.rooms, rooms, sizeof(rooms));  // Ø°Ø®ÛŒØ±Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§ØªØ§Ù‚â€ŒÙ‡Ø§

    save_game("save1.dat", &game_state);
    while (1) {
        move_character(&player_x, &player_y, &prev_cell, &game_state);
        for (int i = 0; i < demon_count; i++) move_demon(&demons[i]);
        for (int i = 0; i < undead_count; i++) move_undead(&undeads[i]);
        for (int i = 0; i < giant_count; i++) move_giant(&giants[i]);
        for (int i = 0; i < snake_count; i++) move_snake(&snakes[i]);
        for (int i = 0; i < fire_count; i++) move_firemonster(&firemonsters[i]);
        mvprintw(1, 0, "â¤ï¸ HP: %d   ğŸ– Hunger: %d ", player_hp, hunger);
        hunger -= 1;
        if (hunger < 0) hunger = 0;

        if (hunger == 0) {
            player_hp -= 1;
            if (player_hp <= 0) {
                game_over_screen();
                return;            }
        }

        show_gold_count();
        int remaining_items = 0;
        for (int y = 0; y < LINES; y++) {
            for (int x = 0; x < COLS; x++) {
                if (  map[y][x] == '&' || map[y][x] == 'B') {
                    remaining_items++;
                }
            }
        }

        if (remaining_items == 0) {
            mvprintw(LINES / 2, (COLS - 20) / 2, "ğŸ† YOU WON THE GAME! ğŸ†");
            refresh();
            sleep(3);
            endwin();
            return;
        }
        refresh();
    }

    getch();
    endwin();
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <ncurses.h>
#include <time.h>

typedef struct {
    char username[100];
    char password[100];
    char email[100];
} User;

int checkemail(const char *email) {
    const char *at = strchr(email, '@');
    if (at == NULL || at == email || strchr(at, '.') == NULL) {
        return 0;
    }
    return 1;
}

void generate_random_password(char *password, int length) {
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    int has_digit = 0, has_upper = 0, has_lower = 0;
    srand(time(NULL));
    for (int i = 0; i < length - 3; i++) {
        int key = rand() % (int)(sizeof(charset) - 1);
        password[i] = charset[key];
        if (isdigit(password[i])) has_digit = 1;
        if (isupper(password[i])) has_upper = 1;
        if (islower(password[i])) has_lower = 1;
    }
    if (!has_digit) password[length - 3] = '0' + rand() % 10;
    if (!has_upper) password[length - 2] = 'A' + rand() % 26;
    if (!has_lower) password[length - 1] = 'a' + rand() % 26;
    password[length] = '\0';
}

int checkpassword(const char *password) {
    if (strlen(password) < 7) {
        return 0;
    }
    int has_digit = 0, has_upper = 0, has_lower = 0;
    for (int i = 0; password[i]; i++) {
        if (isdigit(password[i])) has_digit = 1;
        if (isupper(password[i])) has_upper = 1;
        if (islower(password[i])) has_lower = 1;
    }
    return has_digit && has_upper && has_lower;
}

int checkusername(FILE *file, const char *username) {
    User user;
    rewind(file);
    while (fread(&user, sizeof(User), 1, file)) {
        if (strcmp(user.username, username) == 0) {
            return 1;
        }
    }
    return 0;
}

void get_input(const char *prompt, char *input, int size) {
    clear();
    echo();
    mvprintw(LINES / 2, (COLS - strlen(prompt)) / 2, "%s", prompt);
    refresh();
    getnstr(input, size);
    noecho();
    clear();
}

int authenticate_user(FILE *file, const char *username, const char *password) {
    User user;
    rewind(file);
    while (fread(&user, sizeof(User), 1, file)) {
        if (strcmp(user.username, username) == 0 && strcmp(user.password, password) == 0) {
            return 1;
        }
    }
    return 0;
}

void signin(FILE *file) {
    User new_user;
    char choice;

    get_input("Enter username: ", new_user.username, 100);
    if (checkusername(file, new_user.username)) {
        mvprintw(LINES / 2, (COLS - 30) / 2, "Error: Username already exists.");
        getch();
        return;
    }

    mvprintw(LINES / 2, (COLS - 45) / 2, "Do you want a random password? (y/n): ");
    choice = getch();
    clear();

    if (choice == 'y' || choice == 'Y') {
        generate_random_password(new_user.password, 10);
        mvprintw(LINES / 2, (COLS - 30) / 2, "Random Password: %s", new_user.password);
        getch();
    } else {
        get_input("Enter password: ", new_user.password, 100);
        if (!checkpassword(new_user.password)) {
            mvprintw(LINES / 2, (COLS - 50) / 2, "Error: Password must be at least 7 characters with upper, lower, digit.");
            getch();
            return;
        }
    }

    get_input("Enter email: ", new_user.email, 100);
    if (!checkemail(new_user.email)) {
        mvprintw(LINES / 2, (COLS - 30) / 2, "Error: Invalid email format.");
        getch();
        return;
    }

    fwrite(&new_user, sizeof(User), 1, file);
    strcpy(current_username, new_user.username);  // Ø°Ø®ÛŒØ±Ù‡ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø«Ø¨Øªâ€ŒØ´Ø¯Ù‡
    mvprintw(LINES / 2, (COLS - 30) / 2, "User registered successfully.");
    getch();
}
void forgot_password(FILE *file) {
    char username[100], email[100];
    User user;
    int found = 0;

    get_input("Enter your username: ", username, 100);
    get_input("Enter your email: ", email, 100);

    rewind(file);
    while (fread(&user, sizeof(User), 1, file)) {
        if (strcmp(user.username, username) == 0 && strcmp(user.email, email) == 0) {
            found = 1;
            break;
        }
    }

    clear();
    if (found) {
        mvprintw(LINES / 2, (COLS - 30) / 2, "âœ… Password sent to email.");
    } else {
        mvprintw(LINES / 2, (COLS - 30) / 2, "âŒ Username or email incorrect.");
    }

    getch(); // Ù…Ù†ØªØ¸Ø± ÙØ´Ø±Ø¯Ù† Ú©Ù„ÛŒØ¯ Ø¨Ù…Ø§Ù†Ø¯
}
void show_profile() {
    clear();
    mvprintw(2, (COLS - 20) / 2, "ğŸ‘¤ Profile");
    mvhline(3, (COLS - 20) / 2, '=', 20);
    mvprintw(5, (COLS - 30) / 2, "Username: %s", current_username);
    mvprintw(6, (COLS - 30) / 2, "Total Games Played: 5");
    mvprintw(7, (COLS - 30) / 2, "Highest Score: 1200");
    mvprintw(8, (COLS - 30) / 2, "Gold Collected: 350");

    mvprintw(10, (COLS - 30) / 2, "Press any key to return...");
    refresh();
    getch();
    return;
}
void show_difficulty_menu() {
    const char *difficulties[] = {"ğŸ˜Š Easy (HP: 40)", "ğŸ”¥ Hard (HP: 30)", "ğŸ”™ Back"};
    int choice = 0, key;

    while (1) {
        clear();
        mvprintw(2, (COLS - 25) / 2, "ğŸ® Select Difficulty");
        mvhline(3, (COLS - 25) / 2, '=', 25);

        for (int i = 0; i < 3; i++) {
            if (i == choice) {
                attron(A_REVERSE);
                mvprintw(5 + i, (COLS - 20) / 2, "> %s", difficulties[i]);
                attroff(A_REVERSE);
            } else {
                mvprintw(5 + i, (COLS - 20) / 2, "  %s", difficulties[i]);
            }
        }

        refresh();
        key = getch();
        if (key == KEY_UP && choice > 0) choice--;
        else if (key == KEY_DOWN && choice < 2) choice++;
        else if (key == '\n') {
            if (choice == 0) {
                player_hp = 40;
                mvprintw(10, (COLS - 20) / 2, "ğŸ˜Š Easy mode selected!");
                refresh();
                sleep(1);
                break;
            }
            else if (choice == 1) {
                player_hp = 30;
                mvprintw(10, (COLS - 20) / 2, "ğŸ”¥ Hard mode selected!");
                refresh();
                sleep(1);
                break;
            }
            else break;
        }
    }
}
void show_settings() {
    const char *options[] = {"ğŸ­ Change Character Color", "ğŸ® Change Difficulty", "ğŸ”™ Back"};
    int choice = 0, key;

    while (1) {
        clear();
        mvprintw(2, (COLS - 20) / 2, "âš™ï¸ Settings");
        mvhline(3, (COLS - 20) / 2, '=', 20);

        for (int i = 0; i < 3; i++) {
            if (i == choice) {
                attron(A_REVERSE);
                mvprintw(5 + i, (COLS - 15) / 2, "> %s", options[i]);
                attroff(A_REVERSE);
            } else {
                mvprintw(5 + i, (COLS - 15) / 2, "  %s", options[i]);
            }
        }

        refresh();
        key = getch();
        if (key == KEY_UP && choice > 0) choice--;
        else if (key == KEY_DOWN && choice < 2) choice++;
        else if (key == '\n') {
            if (choice == 0) {
                // ØªØºÛŒÛŒØ± Ø±Ù†Ú¯ Ú©Ø§Ø±Ø§Ú©ØªØ± (Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø² Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ø¶Ø§ÙÙ‡ Ø´ÙˆØ¯)
            }
            else if (choice == 1) {
                show_difficulty_menu();  // Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø³Ø®ØªÛŒ Ø¨Ø§Ø²ÛŒ
            }
            else break;
        }
    }
}


void show_leaderboard() {
    FILE *file = fopen("leaderboard.txt", "r");
    if (!file) {
        mvprintw(LINES / 2, (COLS - 30) / 2, "âš ï¸ No leaderboard data found!");
        getch();
        return;
    }

    char line[100];
    int row = 5;

    clear();
    mvprintw(2, (COLS - 20) / 2, "ğŸ† Leaderboard");
    mvhline(3, (COLS - 20) / 2, '=', 20);
    mvprintw(4, (COLS - 30) / 2, "Rank | Username | Score | Gold | Games Played");

    while (fgets(line, sizeof(line), file)) {
        mvprintw(row++, (COLS - 30) / 2, "%s", line);
    }
    fclose(file);
    getch();

}
void show_saved_games() {
    FILE *file = fopen("save_list.txt", "r");
    if (!file) {
        mvprintw(LINES / 2, (COLS - 30) / 2, "âš ï¸ No saved games found!");
        getch();
        return;
    }

    char saved_games[10][50];
    int count = 0;

    while (fgets(saved_games[count], sizeof(saved_games[count]), file) && count < 10) {
        saved_games[count][strcspn(saved_games[count], "\n")] = 0; // Ø­Ø°Ù Ø®Ø· Ø¬Ø¯ÛŒØ¯
        count++;
    }
    fclose(file);

    if (count == 0) {
        mvprintw(LINES / 2, (COLS - 30) / 2, "âš ï¸ No saved games found!");
        getch();
        return;
    }

    int selection = 0, key;
    while (1) {
        clear();
        mvprintw(2, (COLS - 20) / 2, "ğŸ’¾ Saved Games");
        mvhline(3, (COLS - 20) / 2, '=', 20);

        for (int i = 0; i < count; i++) {
            if (i == selection) {
                attron(A_REVERSE);
                mvprintw(5 + i, (COLS - 15) / 2, "> %s", saved_games[i]);
                attroff(A_REVERSE);
            } else {
                mvprintw(5 + i, (COLS - 15) / 2, "  %s", saved_games[i]);
            }
        }

        refresh();
        key = getch();
        if (key == KEY_UP && selection > 0) selection--;
        else if (key == KEY_DOWN && selection < count - 1) selection++;
        else if (key == '\n') {
            GameState game_state;
            if (load_game(saved_games[selection], &game_state)) {
                start_game();
            }
            break;
        }
    }
}
void show_pre_game_menu() {
    const char *choices[] = {
            "ğŸ® New Game",
            "ğŸ’¾ Continue",
            "ğŸ† Leaderboard",
            "âš™ï¸ Settings",
            "ğŸ‘¤ Profile",
            "ğŸšª Exit"
    };

    int choice_count = sizeof(choices) / sizeof(choices[0]);
    int selection = 0;
    int key;

    clear();
    while (1) {
        clear();
        mvprintw(2, (COLS - 30) / 2, "ğŸ² PRE-GAME MENU ğŸ²");
        mvhline(3, (COLS - 30) / 2, '=', 30);

        // Ù†Ù…Ø§ÛŒØ´ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ
        mvprintw(4, (COLS - 30) / 2, "ğŸ‘¤ Logged in as: %s", current_username);

        for (int i = 0; i < choice_count; i++) {
            if (i == selection) {
                attron(A_REVERSE);
                mvprintw(6 + i, (COLS - 15) / 2, "> %s", choices[i]);
                attroff(A_REVERSE);
            } else {
                mvprintw(6 + i, (COLS - 15) / 2, "  %s", choices[i]);
            }
        }

        refresh();
        key = getch();
        if (key == KEY_UP && selection > 0) selection--;
        else if (key == KEY_DOWN && selection < choice_count - 1) selection++;
        else if (key == '\n') break;
    }

    switch (selection) {
        case 0:  start_game(); return;
        case 1:  show_saved_games(); break;
        case 2:  show_leaderboard(); break;
        case 3:  show_settings(); break;
        case 4:  show_profile(); break;
        case 5:  endwin(); exit(0);
    }
    show_pre_game_menu();
}
void login(FILE *file) {
    char username[100], password[100];

    get_input("Enter username: ", username, 100);
    get_input("Enter password: ", password, 100);

    if (authenticate_user(file, username, password)) {
        strcpy(current_username, username);  // Ø°Ø®ÛŒØ±Ù‡ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ù„Ø§Ú¯ÛŒÙ† Ø´Ø¯Ù‡
        mvprintw(LINES / 2, (COLS - 20) / 2, "Login successful!");
        getch();
        clear();
        show_pre_game_menu();  // Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒ Ø¨Ø¹Ø¯ Ø§Ø² Ù„Ø§Ú¯ÛŒÙ† Ù…ÙˆÙÙ‚
    } else {
        mvprintw(LINES / 2, (COLS - 30) / 2, "Error: Invalid username or password.");
        getch();
    }
}

void login_guest() {
    strcpy(current_username, "Guest");
    clear();
    mvprintw(LINES / 2, (COLS - 20) / 2, "Logged in as guest.");
    getch();
    clear();
    show_pre_game_menu();
}

void show_menu(const char *choices[], int n_choices, FILE *file) {
    int pos = 0;
    WINDOW *menu_win = newwin(15, 50, (LINES - 15) / 2, (COLS - 50) / 2);
    keypad(menu_win, TRUE);
    box(menu_win, 0, 0);

    start_color();
    init_pair(1, COLOR_WHITE, COLOR_BLACK);
    init_pair(2, COLOR_BLACK, COLOR_WHITE);

    while (1) {
        clear();
        refresh();

        wclear(menu_win);
        box(menu_win, 0, 0);
        mvwprintw(menu_win, 1, (50 - strlen("MAIN MENU")) / 2, "MAIN MENU");

        for (int i = 0; i < n_choices; i++) {
            if (i == pos) {
                wattron(menu_win, COLOR_PAIR(2));
                mvwprintw(menu_win, i + 3, 5, "> %s", choices[i]);
                wattroff(menu_win, COLOR_PAIR(2));
            } else {
                wattron(menu_win, COLOR_PAIR(1));
                mvwprintw(menu_win, i + 3, 5, "  %s", choices[i]);
                wattroff(menu_win, COLOR_PAIR(1));
            }
        }

        const char *instruction = "Use arrow keys to navigate and Enter to select.";
        mvwprintw(menu_win, 12, (50 - strlen(instruction)) / 2, "%s", instruction);
        wrefresh(menu_win);

        int input = wgetch(menu_win);
        if (input == KEY_UP && pos > 0) pos--;
        else if (input == KEY_DOWN && pos < n_choices - 1) pos++;
        else if (input == '\n') {
            delwin(menu_win); // Ø­Ø°Ù Ù¾Ù†Ø¬Ø±Ù‡ Ù…Ù†Ùˆ Ù‚Ø¨Ù„ Ø§Ø² Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø¹Ø¯ÛŒ

            if (pos == 0) signin(file);
            else if (pos == 1) login(file);
            else if (pos == 2) forgot_password(file);
            else if (pos == 3) login_guest();
            else {
                fclose(file);
                endwin();
                exit(0);
            }

            // Ø¨Ø§Ø²Ø³Ø§Ø²ÛŒ Ù¾Ù†Ø¬Ø±Ù‡ Ù…Ù†Ùˆ Ø¨Ø¹Ø¯ Ø§Ø² Ø¹Ù…Ù„ÛŒØ§Øª
            menu_win = newwin(15, 50, (LINES - 15) / 2, (COLS - 50) / 2);
            keypad(menu_win, TRUE);
            box(menu_win, 0, 0);
        }
    }
}
void type_text(const char *text, int row, int col) {
    for (int i = 0; i < strlen(text); i++) {
        mvprintw(row, col + i, "%c", text[i]);
        refresh();
        usleep(50000); // 50 Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡ ØªØ£Ø®ÛŒØ± Ø¨ÛŒÙ† Ù‡Ø± Ø­Ø±Ù
    }
}
void show_loading_animation() {
    const char *loading = "Loading";
    for (int i = 0; i < 3; i++) {
        mvprintw(LINES - 2, (COLS - 10) / 2, "%s", loading);
        refresh();
        usleep(300000); // 300 Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡
        mvprintw(LINES - 2, (COLS - 10) / 2, "       "); // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù…ØªÙ†
        refresh();
        usleep(300000);
    }
}
void show_ascii_art() {
    clear();
    start_color();
    init_pair(1, COLOR_WHITE, COLOR_BLACK);
    bkgd(COLOR_PAIR(1));

    int start_y = (LINES - 10) / 2;
    int x_offset = (COLS - 65) / 2;

    attron(COLOR_PAIR(1));
    mvprintw(start_y, x_offset, "â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ ");
    mvprintw(start_y + 1, x_offset, "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        ");
    mvprintw(start_y + 2, x_offset, "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        ");
    mvprintw(start_y + 3, x_offset, "â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–’â–“â–ˆâ–ˆâ–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘   ");
    mvprintw(start_y + 4, x_offset, "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        ");
    mvprintw(start_y + 5, x_offset, "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘        ");
    mvprintw(start_y + 6, x_offset, "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ ");

    mvhline(start_y + 7, (COLS - 50) / 2, '-', 50);

    attron(A_BOLD | A_BLINK);
    mvprintw(start_y + 10, (COLS - 20) / 2, "ğŸ”¥ WELCOME TO FOP 2024 PROJECT ğŸ”¥");
    attroff(A_BOLD | A_BLINK);

    type_text("Press ENTER to continue...", start_y + 12, (COLS - 20) / 2);

    mvprintw(start_y + 14, (COLS - 40) / 2, "\"The journey of a thousand miles begins with one step.\"");

    attron(A_BOLD);
    mvprintw(start_y + 16, (COLS - 25) / 2, "Created by Amin Shabani");
    attroff(A_BOLD);

    attroff(COLOR_PAIR(1));
    refresh();

    show_loading_animation();

    while (getch() != '\n');
}
void save_score_to_leaderboard(const char *username, int gold) {
    FILE *file = fopen("leaderboard.txt", "a");
    if (!file) {
        perror("Error opening leaderboard file");
        return;
    }

    int score = gold * 2;  // Ø§Ù…ØªÛŒØ§Ø² = Ø¯Ùˆ Ø¨Ø±Ø§Ø¨Ø± ØªØ¹Ø¯Ø§Ø¯ Ø·Ù„Ø§Ù‡Ø§

    fprintf(file, "%s %d %d 1\n", username, score, gold);
    fclose(file);
}
int main() {
    setlocale(LC_ALL, "");
    FILE *file = fopen("usersfile", "a+b");
    if (!file) {
        perror("Error opening file");
        return 1;
    }

    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);

    while (1) {  // Ø­Ù„Ù‚Ù‡ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØª Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ Ù¾Ø³ Ø§Ø² Game Over
        show_ascii_art();  // Ù†Ù…Ø§ÛŒØ´ FOP 2024 Ø¨Ø§ ASCII Art
        show_loading_animation();
        const char *choices[] = {"Register", "Login", "Forgot Password", "Login as Guest", "Exit"};
        show_menu(choices, 5, file);

    }

    fclose(file);
    endwin();
    return 0;
}
